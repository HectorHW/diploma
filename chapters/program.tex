\section{Описание разработанной системы}

В данной секции будет рассмотрена общая архитектура фаззера, описан процесс конфигурации и использования фаззера конечным пользователем.

\subsection{Общая архитектура}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.99\textwidth]{arch.png}
	\caption{Диаграмма классов системы}
	\label{fig:arch}
\end{figure}%

Разработанную систему можно условно поделить на компоненты, которые также приведены на рисунке \ref{fig:arch} выше:
\begin{itemize}
	\item библиотека образцов, ответственная за хранение состояния фаззера и выбор очередного кандидата на мутацию на основании хранимой информации о покрытии, как было описано выше;
	
	\item подсистема, ответственная за генерацию данных, выполняющая мутацию и кроссинговер для выбранного ранее образца на базе имеющейся библиотеки. Данный компонент постепенно изменяет параметры распределения вероятностей выбора из имеющихся мутаторов в соответствии с полученными данными о покрытии;
	
	\item подсистема, осуществляющая запуск исполняемого файла. При запуске через файл или стандартный ввод (в зависимости от конфигурации) передаётся очередной образец, выполняется трассировка исполняемого файла при помощи ptrace, как было описано ранее, и в результате мы получаем данные о покрытии (Trace);
	
	\item подсистема, ответственная за вывод информации на экран. Пользователю предоставляется информация о том, как протекает процесс тестирования для информирования и возможной диагностики неполадок.
	
\end{itemize}

В качестве языка реализации был использован язык системного программирования Rust \cite{rust}, поскольку он предоставляет доступ ко всем необходимым системным вызовам и интерфейсам операционной системы и в то же время обладает субъективно высоким уровнем удобства.

\subsection{Конфигурирование}

Для конфигурирования фаззера используется формат Toml. В едином файле fuzz.toml пользователь указывает исполняемый файл, который хочет тестировать, описывает, что будет подаваться на вход, а также при необходимости указывает дополнительные данные, например параметры для алгоритма выбора методов мутации или параметры отдельных мутаторов. Простейшая конфигурация выглядит следующим образом:

\begin{code}
[binary]
# путь до исполняемого файла
path = "./exif"
# указание, как данные будут подаваться на вход
# (stdin по-умолчанию)
pass_style = "file"

[input]
# папка с образцами
seeds = "./examples"
\end{code}

Система допускает задание входа либо в виде готовых примеров и в таком случае будет использовать исключительно бинарные мутации, как это делают классические фаззеры, либо в виде грамматики, и в таком случае пользователю дополнительно нужно будет описать вход в отдельном файле в виде контекстно-свободной грамматики. Грамматика задаётся набором алтернативных продукций вида \ic{N -> P\_1|...|P\_N}, где \ic{N} это нетерминал, а \ic{P\_i} -- один или более элемент из следующего набора:

\begin{itemize}
	\item другой нетерминал, записывающийся по привычному для языков программированиям правилам: первый символ является буквой или символом подчёркивания, а последующие буквами, цифрами или символами подчёркивания (например, \ic{root} или \ic{Number});
	
	\item фиксированная строка, ограниченная двойными кавычками (например, \ic{"SELECT"}). Данный элемент оказывается полезным для описания грамматик, порождающих текстовый ввод;
	
	\item строка, задаваемая регулярным выражением. Для задания регулярного выражения обычную строку следует заключить в re(...), например \ic{re("[a-z][a-z]+")}. Стоит отметить, что функционал регулярных выражений можно эмулировать и с помощью продукций, данный функционал введён для повышения удобства;
	
	\item фиксированная последовательность байт, задаваемая в шестнадцатиричном виде с префиксом 0x, например \ic{0x89504e47}. Данный тип токенов может быть полезен при описании бинарных форматов файлов, например для задания магических чисел -- приведённый ранее пример является magic для файлов формата png;
	
	\item произвольный набор байт, задаваемый литералом bytes. Позволяет указать либо сегмент фиксированной длины (например \ic{bytes(4)}) либо сегмент с длиной в некотором диапазоне (\ic{bytes(5 8)});
	
	\item специальный токен Nothing, позволяющий указывать пустые продукции (это полезно для записи опциональных секций через правило вида \ic{Marker -> 0x9F | Nothing}).
\end{itemize}

Пример грамматики, составленной по данным правилам:
\begin{code}
root -> "SELECT " select_target " FROM " name;
select_target -> "*" | args;
args -> name | args ", " name;
name -> re("[a-z][a-z0-9]*");
\end{code}

\subsection{Пользовательский интерфейс}

Для наблюдения за процессом тестирования и диагностики возможных ошибок конфигурации пользователю предоставляется простой интерфейс в виде терминальной превдографики, который можно видеть на рисунке \ref{fig:tui} ниже. В нём можно выделить четыре секции:

\begin{enumerate}
	\item информация о времени тестирования, сообщающая пользователю о том, как долго протекает процесс тестирования и как давно происходили некоторые интересные события (обнаружение новых путей в программе и обнаружение уникальных крашей);
	
	\item информация о запуске программы, отображающая общее число запусков и разбивку по категориям (успешное завершение, с кодом ошибки, краш), а также среднюю скорость выполнения и число успешных минимизаций тестовых примеров;
	
	\item информация о том, как много уникальных поведений программы -- путей, кодов возврата и крашей -- было обнаружено;
	
	\item секция с сообщениями системы.
\end{enumerate}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.99\textwidth]{tui.png}
	\caption{Терминальный интерфейс}
	\label{fig:tui}
\end{figure}%