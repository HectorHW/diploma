\section{Генерация входных данных}

Для формирования входных данных выделяют два подхода:

\begin{itemize}
	
	\item на основе символьного исполнения, заключающийся в построении системы уравнений на основе условий, которые необходимо выполнить для прохождения конкретного пути в программе;
	
	\item генеративный, заключающийся в применении простых операций вроде инверсии битов или копирования и удаления сегментов данных для формирования новых образцов.
	
\end{itemize}

Далее будут более детально рассмотренны описанные подходы.

\subsection{Символьное исполнение}

Символьное исполнение -- подход, полагающийся на построение и решение систем уравнений на основе условий, встречающихся при прохождении того или иного пути в программе. Рассмотрим следующую программу на языке Python:
\begin{code}
x = int(input())      # 1
if x > 2:
    print("big")      # 2
while x > 0:          # 3
   print("decrease")  # 4
   x -= 1

print("done")         # 5
\end{code}

Если представить каждую точку, в которой происходит изменение потока управления, в виде узла графа, а участки программы, в которые возможно попасть из текущего, соединить рёбрами, получим граф. В этом графе путь из начальной вершины в конечную будет соответствовать некоторому выполнению программы. Граф, соответствующий программе выше, приведён на рисунке \ref{fig:py-control-flow-graph}.

Далее, рассмотрим какой-нибудь путь в программе, например 1 - 3 - 4 - 3 - 5. Выписав логические условия, которые встречаются на переходах, и преобразования над данными ($\neg (x > 2) \ \& \ x > 0 \ \& \ x'=x \ \& \ \neg (x'>0) $ ) и решив систему, возможно выяснить, что необходимое значение $x = 1$.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{program-states.png}
	\caption{Граф, соответствующий программе}
	\label{fig:py-control-flow-graph}
\end{figure}%

Таким образом возможно явно перебирать пути выполнения, решая для каждого из них систему уравнений и получая приводящий к выбранной траектории пример данных. Данный подход нашёл применение, например, в системе KLEE, применяющей символьное исполнение с измерением покрытия для автоматической генерации тестовых примеров \cite{klee}. Данная система реализует символьное исполнение в виде своеобразного интерпретатора биткода llvm для поиска исчерпывающего набора тестовых примеров. Причём, полученные таким образом тесты часто способны опережать в плане покрытия кода тесты, написанные человеком, обладающим знаниями о структуре исследуемой программы.

Одной из проблем исследования программ посредством символьного исполнения является экспоненциальный рост пространства возможных путей в программе, а также высокая сложность решения полученных в результате символьного исполнения уравнений. В связи с этим на практике символьное исполнение редко применяется, вместо него в большинстве систем используется случайная генерация тестовых примеров. Но одна из особенностей символьного исполнения -- явное выделение путей в программе -- оказывается очень полезной для исследования более простыми методами, позволяя значительно повысить их эффективность за счёт отбора изменений, приводящих к повышению покрытия программы, что будет рассмотренно в главе \ref{sec:trace}.

\subsection{Генеративный подход}

Генеративный подход, иногда именуемый "умным рандомом", состоит в применении к существующим образцам данных простых операций, в подавляющем большинстве случаев работающих случайным образом, в надежде получить образцы, на которых программа проявит новое поведение. Для применения данного подхода большое значение имеет начальный набор образцов, из которого фаззер может отбирать участки данных, а также сбор информации о покрытии программы для выявления уникальных образцов и эффективных мутаций.

Несмотря на свою простоту, этот подход зарекомендовал себя как стандарт в индустрии, так как его применение возможно в условиях отсутствия знания о структуре программы или формате данных, ожидаемых ею на входе.

\subsection{Генерация при помощи грамматики}

Часто генеративный подход сталкивается с проблемами при работе с программами, вход которых имеет строгую структуру. Например, если проводится фаззинг интерпретатора языка программирования, подавляющее большинство полученных в результате работы фаззера образцов данных, полученных на основе случайных мутаций, будут отбраковываться модулями лексического и синтаксического анализа, что может привести к неизмеримо большому количеству безуспешных запусков программы. 

Более совершенной разновидностью генеративного подхода, пригодной для работы с структурированными данными, является генерация на основе грамматики. Фаззеру на вход подаются правила, задающие общую структуру данных, а вместо простых операций вроде инверсии битов применяется случайный выбор продукций грамматики, в результате чего получаем синтаксическое дерево. Свернув терминальные узлы синтаксического дерева, получим последовательность байт, которую уже можно подавать на вход программе.

Например, рассмотрим следующую грамматику, описывающую математические выражения:
\begin{align*}
	Root &\rightarrow Number \ | \ Root \ Operator \ Root \\
	Number &\rightarrow regex("0|[0-9]\backslash d+") \\
	Operator &\rightarrow "+" \ | \ "-" \ | \ "*" \ | \ "/"	
\end{align*}
где $"+"$ -- терминал, описываемый строкой, а $regex(string)$ -- терминал, соответствующий заданному регулярному выражению. Генерацию ввода по грамматике можно проводить следующим образом рекурсивно: находясь в нетерминале $N$, которому соответствует правило $N \rightarrow E_1 \ | \ ...\  | \ E_n$, случайным образом равновероятно выбрать одно из правил вывода $E_i$, заменить нетерминал $N$ на последовательность терминалов и нетерминалов, и для каждого нетерминала в полученной последовательности операцию повторить. Пример генерации дерева продемонстрирован на рисунке \ref{fig:tree_expansion}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.99\textwidth]{tree-expansion.png}
	\caption{Генерация дерева случайным применением продукций}
	\label{fig:tree_expansion}
\end{figure}%

При этом может потребоваться ввести ограничение на глубину результирующего дерева. В таком случае стоит дополнительно учитывать текущий уровень вложенности, а генерацию дерева ограничить конечным числом попыток. При рассмотрении очередного нетерминала проверим, что оставшийся запас вложенности не нулевой, и в случае, если это не так, посчитаем попытку генерации неудачной и сообщим об этом на уровень выше, попытавшись применить другое правило, а успешной будем считать попытку, в результате которой все нетерминалы в правой части правила вывода были успешно сгенерированы.

После генерации дерева необходимо свернуть его в последовательность байт, которую можно подать программе. Для этого можно также использовать рекурсивный обход, сворачивая поддеревья слева направо, в результате чего выпишутся все терминалы. Например, для рассматриваемого дерева (рисунок \ref{fig:tree_folding}) терминалами будут "7", "+", "2", "*", "15", которые свернутся в строку "7+2*15".

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{tree.png}
	\caption{Дерево, построенное по заданной грамматике}
	\label{fig:tree_folding}
\end{figure}%

\subsection{Мутации дерева}

Введение промежуточного представления позволяет реализовать новые, более высокоуровневые мутации, способные учитывать структуру ввода. Если сохранить в дереве информацию о том, какое правило вывода было использовано для генерации того или иного поддерева, станет возможным, во-первых, регенерировать в существующем дереве его участки, просто стирая поддерево с корнем в некотором узле и заново применяя правило продукции случайным образом; во-вторых, появится возможность сохранять и в дальнейшем повторно использовать удачно сгенерированные образцы деревьев соответствующих типов, которые привели к выявлению нового поведения программы.

Далее, для обнаружения ошибок в парсере возможно позволить с небольшой вероятностью производить вставку дерева, являющегося результатом применения продукции, которая не ожидается в данном участке входа, дабы не создавать жёстких ограничений на пространство поиска фаззера, а скорее рассматривать заданные правила как рекомендации.

Наконец, возможно сочетание с классическими мутационными алгоритмами за счёт применения мутаций к терминальным вершинам в синтаксичеком дереве. Кроме того, в случае, если необходимо обнаруживать ошибки в самом парсере исследуемой программы, можно добавить возможность применять примитивные мутации, работающие на уровне байт, к элементам дерева, которые грамматика не даёт мутировать, например константы или ключевые слова. Для этого для каждого терминала будем дополнительно хранить информацию об области, которой он соответствует в итоговом свёрнутом виде, а при применении мутации найдём все терминалы, к которым она применяется и изменим их. Такой подход позволит сохранить байтовые мутации при работе с деревьями в привычном виде. Пример подобного можно увидеть на рисунке \ref{fig:tree_modification} -- модификация применяется к соответствующим участкам литералов B и C.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{tree-modification.png}
	\caption{Модификация терминалов на основе диапазонов}
	\label{fig:tree_modification}
\end{figure}%

\subsection{Генетические алгоритмы}

Одним из подходов к решению задач поиска является применение генетических алгоритмов. Данный подход сводится к введению метрики (fitness function), и поиска решения, её улучшающего, за счёт применения к популяции вариантов решения мутаций (случайных изменений, выполняемых как правило при формировании новых образцов) и скрещивания (рекомбинация частей решений-кандидатов). Метрика указывает, насколько хорош или близок к оптимальному конкретный вариант решения задачи, но за счёт добавления в неё дополнительных слагаемых также можно вводить мягкие ограничения на сложность решений, например ограничивать глубину дерева при помощи штрафов. Генетические алгоритмы оказываются полезны в задачах, которые допускают неточное, приближённое решение.

Генетические алгоритмы оказываются полезны в том числе и в фаззинге. Примером подобного подхода является iFuzzer, предназначенный специально для фаззинга интерпретаторов языков программирования \cite{ifuzzer}. Данный фаззер руководствуется описанием грамматики целевого языка программирования для генерации тестовых примеров и использует подходы генетических алгоритмов -- fitness function, мутацию и кроссинговер -- для выбора существующих и генерации новых образцов, за счёт чего он способен создавать разнообразные образцы корректных с точки зрения целевого парсера программ. Применение fitness function позволяет ограничить разрастание генерируемых образцов за счёт введения штрафов, зависящих от размера программы, таким образом стремясь к генерации примеров наименьшей длины и наиболее разнообразной популяции.

Также для поддержания семантической корректности при мутации данный фаззер использует подход с переиспользованием литералов, заключающися в ограничении выбора имён переменных из уже существующих в синтаксическом дереве и переименовании переменных при модификации синтаксического дерева в процессе мутации. Это становится возможным благодаря явной разметке в грамматике участков, являющихся именованными сущностями.
