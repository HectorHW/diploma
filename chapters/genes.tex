\section{Генерация входных данных}

Для формирования входных данных выделяют два подхода:

\begin{itemize}
	
	\item на основе символьного исполнения, заключающийся в построении системы уравнений на основе условий, которые необходимо выполнить для прохождения конкретного пути в программе;
	
	\item генеративный, заключающийся в применении простых операций вроде инверсии битов или копирования и удаления сегментов данных для формирования новых образцов.
	
\end{itemize}

Далее будут более детально рассмотренны описанные подходы.

\subsection{Символьное исполнение}

Символьное исполнение -- 

\subsection{Генеративный подход}

Генеративный подход, иногда именуемый "умным рандомом", состоит в применении к существующим образцам данных простых операций, в подавляющем большинстве случаев работающих случайным образом, в надежде получить образцы, на которых программа проявит новое поведение. Для применения данного подхода большое значение имеет начальный набор образцов, из которого фаззер может отбирать участки данных.

Не смотря на свою простоту, этот подход зарекомендовал себя как стандарт в индустрии, так как его применение возможно в условиях отсутствия знания о структуре программы или формате данных, ожидаемых ею на входе.

\subsection{Генерация при помощи грамматики}

Часто генеративный подход сталкивается с проблемами при работе с программами, вход которых имеет строгую структуру. Например, если мы фаззим интерпретатор языка программирования, подавляющее большинство полученных в результате работы фаззера образцов данных, полученных на основе случайных мутаций, будут отбраковываться модулями лексического и синтаксического анализа, что может привести к неизмеримо большому количеству безуспешных запусков программы. 

Более совершенной разновидностью генеративного подхода, пригодной для работы с структурированными данными, является генерация на основе грамматики. Фаззеру на вход подаются правила, задающие общую структуру данных, а вместо простых операций вроде инверсии битов применяется случайный выбор продукций грамматики, в результате чего получаем синтаксическое дерево. Свернув терминальные узлы синтаксического дерева, получим последовательность байт, которую уже можно подавать на вход программе.

Например, рассмотрим следующую грамматику, описывающую математические выражения:
\begin{align*} % TODO: строки в виде моноширинного текста
	Root &\rightarrow Number \ | \ Root \ Operator \ Root \\
	Number &\rightarrow regex("0|[0-9]\backslash d+") \\
	Operator &\rightarrow "+" \ | \ "-" \ | \ "*" \ | \ "/"	
\end{align*}
где $"+"$ -- терминал, описываемый строкой, а $regex(string)$ -- терминал, соответствующий заданному регулярному выражению. Генерацию ввода по грамматике можно проводить следующим образом рекурсивно: находясь в нетерминале $N$, которому соответствует правило $N \rightarrow E_1 \ | \ ...\  | \ E_n$, случайным образом равновероятно выбрать одно из правил вывода $E_i$, заменить нетерминал $N$ на последовательность терминалов и нетерминалов, и для каждого нетерминала в полученной последовательности операцию повторить.

При этом нам может потребоваться ввести ограничение на глубину результирующего дерева. В таком случае стоит дополнительно учитывать текущий уровень вложенности, а генерацию дерева ограничить конечным числом попыток. При рассмотрении очередного нетерминала проверим, что оставшийся запас вложенности не нулевой, и в случае, если это не так, посчитаем попытку генерации неудачной и сообщим об этом на уровень выше, попытавшись применить другое правило, а успешной будем считать попытку, в результате которой все нетерминалы в правой части правила вывода были успешно сгенерированы.

После генерации дерева необходимо свернуть его в последовательность байт, которую можно подать программе. Для этого можно также использовать рекурсивный обход, сворачивая поддеревья слева направо, в результате чего мы выпишем все терминалы. Например, для следующего дерева (Рисунок \ref{fig:tree_folding}) терминалами будут "7", "+", "2", "*", "15", которые свернутся в строку "7+2*15".

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{tree.png}
	\caption{Дерево, построенное по заданной грамматике}
	\label{fig:tree_folding}
\end{figure}%

\subsection{Мутации дерева}

Введение промежуточного представления позволяет реализовать новые, более высокоуровневые мутации, способные учитывать структуру ввода. Если мы сохраним в дереве информацию о том, какое правило вывода было использовано для генерации того или иного поддерева, станет возможным, во-первых, регенерировать в существующем дереве его участки, просто стирая поддерево с корнем в некотором узле и заново применяя правило продукции случайным образом; во-вторых, мы получим возможность сохранять и в дальнейшем повторно использовать удачно сгенерированные образцы деревьев соответствующих типов, которые привели к выявлению нового поведения программы.

Далее, для обнаружения ошибок в парсере мы можем позволить с небольшой вероятностью производить вставку дерева, являющегося результатом применения продукции, которая не ожидается в данном участке входа, дабы не создавать жёстких ограничений на пространство поиска фаззера, а скорее рассматривать заданные правила как рекомендации.

Наконец, возможно сочетание с классическими мутационными алгоритмами за счёт внедрения в результирующее синтаксическое дерево блоков, содержащих двоичные данные. Кроме того, в случае, если нам необходимо обнаруживать ошибки в самом парсере исследуемой программы, мы можем добавить возможность применять примитивные мутации, работающие на уровне байт, к элементам дерева, которые грамматика не даёт мутировать, например константы или ключевые слова. Для этого для каждого образца сохраним помимо дерева набор байтовых модификаций, представляющих собой структуру, включающую позицию применения той или иной мутации, её тип, а также дополнительные данные, если требуется. Например, если мы в результирующем образце данных хотим заменить некоторый байт на $\mathtt{0xFF}_{16} = \mathtt{255}_{10}$, сохраним для этого изменения структуру вида $\langle k, \ Replace, \ 255 \rangle$, где $k$ - позиция байта, который мы хотим заменить. Для формирования результата мы сначала свернём синтаксическое дерево как обычно, а затем применим все байтовые изменения. Также при таком подходе становится возможным сохранение этих изменений при копировании участков из одного дерева в другое -- достаточно при копировании вычислить, какому диапазону индексов в свёрнутом векторе соответствует поддерево, и скопировать вместе с ним и все байтовые мутации, приходящиеся на этот диапазон.

\subsection{Генетические алгоритмы}

% TODO генетические алгоритмы

Примером подобного подхода является iFuzzer, предназначенный специально для фаззинга интерпретаторов языков программирования \cite{ifuzzer}. Данный фаззер руководствуется описанием грамматики целевого языка программирования для генерации тестовых примеров и использует подходы генетических алгоритмов -- fitness function, мутацию и кроссинговер -- для выбора существующих и генерации новых образцов, за счёт чего он способен создавать разнообразные образцы корректных с точки зрения целевого парсера программ. Применение fitness function позволяет ограничить разрастание генерируемых образцов за счёт введения штрафов, зависящих от размера программы, таким образом стремясь к генерации примеров наименьшей длины и наиболее разнообразной популяции.

Также для поддержания семантической корректности при мутации данный фаззер использует подход с переиспользованием литералов, заключающися в ограничении выбора имён переменных из уже существующих в синтаксическом дереве и переименовании переменных при модификации синтаксического дерева в процессе мутации. Это становится возможным благодаря явной разметке в грамматике участков, являющихся именованными сущностями.
