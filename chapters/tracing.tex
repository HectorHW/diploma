\section{Трассировка}\label{sec:trace}

Важным компонентом, значительно ускоряющим процесс фаззинга, является измерение покрытия кода программы при запуске очередного тестового примера. Существует несколько подходов для измерения покрытия, они будут рассмотрены далее.


\subsection{Статическая инструментация}

Статическая инструментация программы, полагающаяся на применение специальных библиотек и компиляторов, добавляющих в программу инструкции, на которые затем ориентируется фаззер для точного выяснения траектории выполнения программы.

Плюсом такого подхода является быстрота проведения фаззинга (например, в программе может быть искусственно выделена та или иная секция, подвергаемая тестированию в бесконечном цикле, за счёт чего отпадает необходимость в трате ресурсов на постоянный запуск новых процессов и загрузки библиотек).

Минус данного подхода состоит в необходимости наличия доступа к исходному коду программы и необходимости дополнительной работы, заключающейся в подключении специальных заголовочных файлов, выделении тестируемых участков программы, а также компиляции при помощи специальных инструментов.

Одним из фаззеров, использующих статическую инструментацию, является American fuzzy lop, или коротко afl \cite{afl}. Данная инструмент предоставляет большой набор подходов, позволяющих сделать фаззинг быстрее и эффективнее:

\begin{itemize}
	\item afl-gcc -- специальный компилятор, предназначенный для генерации исполняемых файлов с дополнительной инструментацией, используемой фаззером. Помимо прочего, afl-gcc может производить дополнительное мероприятия по "укреплению" (hardening) исполняемых файлов, что позволяет более эффективно обнаруживать ошибки в работе с памятью; 
	\item afl-trim %TODO
\end{itemize}

\subsection{QEMU mode}

В тех случаях, когда доступа к исходному коду программы нет, необходимо прибегать к другим методам, если мы хотим иметь возможность использовать покрытие программы. Одним из вариантов, применяемых в том числе и в afl, является запуск программы в эмуляторе. Исполняемый файл запускается в легковесном эмуляторе, а при выполнении инструкций, отвечающих за изменение потока выполнения программы, например инструкций \inlinecode{jmp} или \inlinecode{call}, информация об текущем значении указателя инструкций записывается, за счёт чего мы можем построить путь в пространстве состояний программы. Фаззер afl реализует данный подход при помощи модифицированного эмулятора QEMU, при этом происходит эмуляция только кода в пространстве пользователя, а выполнение системных вызовов и взаимодействие с ядром происходит как обычно.

Преимуществом данного подхода является его универсальность -- мы больше не нуждаемся в доступе к исходному коду и не обязаны выполнять компиляцию специализированными инструментами, фаззер можно применить к любому исполняемому файлу. Кроме того, за счёт применения эмулятора у нас появляется возможность проводить фаззинг исполняемых файлов, скомпилированных для архитектуры процессора, отличающейся от таковой на нашей машине, например фаззить программы под arm64 на компьютерах с процессорами на архитектуре intel.

Очевидной проблемой, возникающей при применении эмулятора, является негативное влияние на скорость выполнения программы, что особенно важно при генеративном подходе. В случае использования afl и QEMU замедление оказывается в 2-5 раз. Для снижения этого влияния авторы afl предлагают в том числе механизм fork server, сводящийся к модификации исполняемого файла за счёт внедрения перед точкой входа небольшого фрагмента машинного кода, выполняющего в бесконечном цикле fork для создания собственных копий. Это позволяет за счёт механизма copy on write в linux выполнить загрузку динамических библиотек только один раз и таким образом увеличить долю времени, затрачиваемую на выполнение исследуемого кода.

\subsection{Динамическая инструментация при помощи ptrace}

Динамическая инструментация программы полагается на использование методов, схожих с таковыми, применяемыми в отладчиках - для сбора информации о траектории выполнения программы применяются точки останова, в которых записывается состояние регистра счётчика команд. В отличие от предыдущего подхода, в данном случае возможна работа с уже готовым исполняемым файлом, мы можем и не иметь исходного кода исследуемой программы.

Проблемой динамической инструментации является серьёзное влияние на скорость выполнения программы, вызванное необходимостью обрабатывать большое число прерываний и системных вызовов при общении между исследуемой программой и программой-трассировщиком, из-за чего время выполнения увеличивается пропорционально числу попадания указателя инструкций на точку останова.

Для снижения этого влияния могут применяться различные методы, например Coverage-guided tracing \cite{full-speed-fuzzing}. Данный подход предлагает вместо создающего серьёзную вычислительную нагрузку полного отслеживания траектории выполнения выявлять только факт посещения новых, ранее не обследованных участков программы. В данном случае мы исходим из предположения, что львиная доля тестовых примеров не вносит вклада в обнаружение новых участков программы, а вместо этого проходит по уже известным путям, и процент таких примеров по мере исследования программы увеличивается, а вероятность обнаружить непосещённый участок снижается.
