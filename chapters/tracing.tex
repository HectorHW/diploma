\section{Трассировка}\label{sec:trace}

Важным компонентом, значительно ускоряющим процесс фаззинга, является измерение покрытия кода программы при запуске очередного тестового примера. Существует несколько подходов для контроля исследуемой программы и измерения покрытия, они будут рассмотрены далее.


\subsection{Статическая инструментация}

Статическая инструментация программы, полагающаяся на применение специальных библиотек и компиляторов, добавляющих в программу инструкции, на которые затем ориентируется фаззер для точного выяснения траектории выполнения программы.

Плюсом такого подхода является быстрота проведения фаззинга (например, в программе может быть искусственно выделена та или иная секция, подвергаемая тестированию в бесконечном цикле, за счёт чего отпадает необходимость в трате ресурсов на постоянный запуск новых процессов и загрузки библиотек).

Минус данного подхода состоит в необходимости наличия доступа к исходному коду программы и необходимости дополнительной работы, заключающейся в подключении специальных заголовочных файлов, выделении тестируемых участков программы, а также компиляции при помощи специальных инструментов.

Одним из фаззеров, использующих статическую инструментацию, является American fuzzy lop, или коротко afl \cite{afl}. Данная инструмент предоставляет большой набор подходов, позволяющих сделать фаззинг быстрее и эффективнее:

\begin{itemize}
	\item afl-gcc -- специальный компилятор, предназначенный для генерации исполняемых файлов с дополнительной инструментацией, используемой фаззером. Помимо прочего, afl-gcc может производить дополнительное мероприятия по "укреплению" (hardening) исполняемых файлов, что позволяет более эффективно обнаруживать ошибки в работе с памятью; 
	\item afl-trim %TODO
\end{itemize}

\subsection{QEMU mode}

В тех случаях, когда доступа к исходному коду программы нет, необходимо прибегать к другим методам, если мы хотим иметь возможность использовать покрытие программы. Одним из вариантов, применяемых в том числе и в afl, является запуск программы в эмуляторе. Исполняемый файл запускается в легковесном эмуляторе, а при выполнении инструкций, отвечающих за изменение потока выполнения программы, например инструкций \inlinecode{jmp} или \inlinecode{call}, информация об текущем значении указателя инструкций записывается, за счёт чего мы можем построить путь в пространстве состояний программы. Фаззер afl реализует данный подход при помощи модифицированного эмулятора QEMU, при этом происходит эмуляция только кода в пространстве пользователя, а выполнение системных вызовов и взаимодействие с ядром происходит как обычно.

Преимуществом данного подхода является его универсальность -- мы больше не нуждаемся в доступе к исходному коду и не обязаны выполнять компиляцию специализированными инструментами, фаззер можно применить к любому исполняемому файлу. Кроме того, за счёт применения эмулятора у нас появляется возможность проводить фаззинг исполняемых файлов, скомпилированных для архитектуры процессора, отличающейся от таковой на нашей машине, например фаззить программы под arm64 на компьютерах с процессорами на архитектуре intel.

Очевидной проблемой, возникающей при применении эмулятора, является негативное влияние на скорость выполнения программы, что особенно важно при генеративном подходе. В случае использования afl и QEMU замедление оказывается в 2-5 раз. Для снижения этого влияния авторы afl предлагают в том числе механизм fork server, сводящийся к модификации исполняемого файла за счёт внедрения перед точкой входа небольшого фрагмента машинного кода, выполняющего в бесконечном цикле fork для создания собственных копий. Это позволяет за счёт механизма copy on write в linux выполнить загрузку динамических библиотек только один раз и таким образом увеличить долю времени, затрачиваемую на выполнение исследуемого кода.

\subsection{Динамическая инструментация}

Динамическая инструментация программы полагается на использование методов, схожих с таковыми, применяемыми в отладчиках - для сбора информации о траектории выполнения программы применяются точки останова, в которых записывается состояние регистра счётчика команд. Мы точно также можем работать с уже готовым исполняемым файлом и не иметь исходного кода исследуемой программы.

Проблемой динамической инструментации является серьёзное влияние на скорость выполнения программы, вызванное необходимостью обрабатывать большое число прерываний и системных вызовов при общении между исследуемой программой и программой-трассировщиком, из-за чего время выполнения увеличивается пропорционально числу попадания указателя инструкций на точку останова.

Для снижения этого влияния могут применяться различные методы, например Coverage-guided tracing \cite{full-speed-fuzzing}. Данный подход предлагает вместо создающего серьёзную вычислительную нагрузку полного отслеживания траектории выполнения выявлять только факт посещения новых, ранее не обследованных участков программы. В данном случае мы исходим из предположения, что львиная доля тестовых примеров не вносит вклада в обнаружение новых участков программы, а вместо этого проходит по уже известным путям, и процент таких примеров по мере исследования программы увеличивается, а вероятность обнаружить непосещённый участок снижается.

\subsection{Трассировка при помощи ptrace}

Для контроля выполнения программ операционная система Linux предоставляет системный вызов ptrace. Он позволяет:

\begin{itemize}
	\item читать память дочернего процесса через \inlinecode{ptrace(PTRACE\_PEEKDATA, addr)} и регистры при помощи \inlinecode{ptrace(PTRACE\_GETREGS)}, за счёт чего мы получаем возможность наблюдать состояние программы, например отслеживать состояние регистра указателя инструкций;
	
	\item модифицировать память и регистры дочернего процесса при помощи \inlinecode{ptrace(PTRACE\_POKEDATA, addr, data)} и \inlinecode{ptrace(PTRACE\_SETREGS, addr, data)}, за счёт чего мы получаем возможность управлять выполнением программы, а также модифицировать её код прямо во время выполнения;
	
	\item продолжать выполнение дочернего процесса, выполняя \inlinecode{ptrace(PTRACE\_CONT)} для просто запуска, \inlinecode{ptrace(PTRACE\_SYSCALL)} для запуска процесса до выполнения им системного вызова и \inlinecode{ptrace(PTRACE\_SINGLESTEP)} для запуска с выполнением единственной инструкции. Последний вариант в том числе позволяет обрабатывать точки останова через добавление в код программы инструкций, вызывающих прерывания, что используется в дебаггерах.
\end{itemize}

Основное применение данного системного вызова -- реализация с его помощью дебаггеров и других инструментов. Типичная последовательность использования ptrace выглядит следующим образом:

\begin{enumerate}
	\item родительский процесс (tracer) создаёт свою копию при помощи \inlinecode{fork};
	
	\item созданный дочерний процесс, возможно, выполняет некоторый код инициализации и сообщает, что хочет стать целью отслеживания через \inlinecode{ptrace(PTRACE\_TRACEME)};
	
	\item созданный дочерний процесс выполняет запуск целевого исполняемого файла через ещё один системный вызов \inlinecode{execve};
	
	\item родительский процесс ожидает сообщений от дочернего процесса через системные вызовы вроде \inlinecode{waitpid}.
\end{enumerate}
