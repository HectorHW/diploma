\section{Трассировка}\label{sec:trace}

Важным компонентом, значительно ускоряющим процесс фаззинга, является измерение покрытия кода программы при запуске очередного тестового примера. Существует несколько подходов для контроля исследуемой программы и измерения покрытия, они будут рассмотрены далее.


\subsection{Статическая инструментация}

Статическая инструментация программы, полагающаяся на применение специальных библиотек и компиляторов, добавляющих в программу инструкции, на которые затем ориентируется фаззер для точного выяснения траектории выполнения программы.

Плюсом такого подхода является быстрота проведения фаззинга (например, в программе может быть искусственно выделена та или иная секция, подвергаемая тестированию в бесконечном цикле, за счёт чего отпадает необходимость в трате ресурсов на постоянный запуск новых процессов и загрузки библиотек).

Минус данного подхода состоит в необходимости наличия доступа к исходному коду программы и необходимости дополнительной работы, заключающейся в подключении специальных заголовочных файлов, выделении тестируемых участков программы, а также компиляции при помощи специальных инструментов.

Одним из фаззеров, использующих статическую инструментацию, является American Fuzzy Lop, или коротко afl \cite{afl}. Данная инструмент предоставляет большой набор подходов, позволяющих сделать фаззинг быстрее и эффективнее:

\begin{itemize}
	\item afl-gcc и afl-clang -- специальные компиляторы, предназначенные для генерации исполняемых файлов с дополнительной инструментацией, используемой фаззером. Помимо прочего, они могут производить дополнительное действия по "укреплению" (hardening) исполняемых файлов, что позволяет более эффективно обнаруживать ошибки в работе с памятью;
	
	\item afl-trim %TODO
\end{itemize}

\subsection{QEMU mode}

В тех случаях, когда доступа к исходному коду программы нет, необходимо прибегать к другим методам, если мы хотим иметь возможность использовать покрытие программы. Одним из вариантов, применяемых в том числе и в afl, является запуск программы в эмуляторе. Исполняемый файл запускается в легковесном эмуляторе, а при выполнении инструкций, отвечающих за изменение потока выполнения программы, например инструкций \inlinecode{jmp} или \inlinecode{call}, информация об текущем значении указателя инструкций записывается, за счёт чего мы можем построить путь в пространстве состояний программы. Фаззер afl реализует данный подход при помощи модифицированного эмулятора QEMU, при этом происходит эмуляция только кода в пространстве пользователя, а выполнение системных вызовов и взаимодействие с ядром происходит как обычно.

Преимуществом данного подхода является его универсальность -- мы больше не нуждаемся в доступе к исходному коду и не обязаны выполнять компиляцию специализированными инструментами, фаззер можно применить к любому исполняемому файлу. Кроме того, за счёт применения эмулятора у нас появляется возможность проводить фаззинг исполняемых файлов, скомпилированных для архитектуры процессора, отличающейся от таковой на нашей машине, например фаззить программы под arm64 на компьютерах с процессорами на архитектуре intel.

Очевидной проблемой, возникающей при применении эмулятора, является негативное влияние на скорость выполнения программы, что особенно важно при генеративном подходе. В случае использования afl и QEMU замедление оказывается в 2-5 раз. Для снижения этого влияния авторы afl предлагают в том числе механизм fork server, сводящийся к модификации исполняемого файла за счёт внедрения перед точкой входа небольшого фрагмента машинного кода, выполняющего в бесконечном цикле fork для создания собственных копий. Это позволяет за счёт механизма copy on write в linux выполнить загрузку динамических библиотек только один раз и таким образом увеличить долю времени, затрачиваемую на выполнение исследуемого кода.

\subsection{Динамическая инструментация}

Динамическая инструментация программы полагается на использование методов, схожих с таковыми, применяемыми в отладчиках - для сбора информации о траектории выполнения программы применяются точки останова, в которых записывается состояние регистра счётчика команд. Мы точно также можем работать с уже готовым исполняемым файлом и не иметь исходного кода исследуемой программы.

Проблемой динамической инструментации является серьёзное влияние на скорость выполнения программы, вызванное необходимостью обрабатывать большое число прерываний и системных вызовов при общении между исследуемой программой и программой-трассировщиком, из-за чего время выполнения увеличивается пропорционально числу попадания указателя инструкций на точку останова.

Для снижения этого влияния могут применяться различные методы, например Coverage-guided tracing \cite{full-speed-fuzzing}. Данный подход предлагает вместо создающего серьёзную вычислительную нагрузку полного отслеживания траектории выполнения выявлять только факт посещения новых, ранее не обследованных участков программы. В данном случае мы исходим из предположения, что львиная доля тестовых примеров не вносит вклада в обнаружение новых участков программы, а вместо этого проходит по уже известным путям, и процент таких примеров по мере исследования программы увеличивается, а вероятность обнаружить непосещённый участок снижается.

\subsection{Трассировка при помощи ptrace}

Для контроля выполнения программ операционная система Linux предоставляет системный вызов ptrace \cite{ptrace}. Он позволяет:

\begin{itemize}
	\item читать память дочернего процесса через \ic{ptrace(PTRACE\_PEEKDATA, addr)} и регистры при помощи \ic{ptrace(PTRACE\_GETREGS)}, за счёт чего мы получаем возможность наблюдать состояние программы, например отслеживать состояние регистра указателя инструкций;
	
	\item модифицировать память и регистры дочернего процесса при помощи \ic{ptrace(PTRACE\_POKEDATA, addr, data)} и \ic{ptrace(PTRACE\_SETREGS, addr, data)}, за счёт чего мы получаем возможность управлять выполнением программы, а также модифицировать её код прямо во время выполнения;
	
	\item продолжать выполнение дочернего процесса, выполняя \ic{ptrace(PTRACE\_CONT)} для просто запуска, \ic{ptrace(PTRACE\_SYSCALL)} для запуска процесса до выполнения им системного вызова и \ic{ptrace(PTRACE\_SINGLESTEP)} для запуска с выполнением единственной инструкции. Последний вариант в том числе позволяет обрабатывать точки останова через добавление в код программы инструкций, вызывающих прерывания, что используется в дебаггерах, и в том числе пригодится в дальнейшем.
\end{itemize}

Основное применение данного системного вызова -- реализация с его помощью дебаггеров и других инструментов, например инструментов аудита, отслеживающих системные вызовы. Типичная последовательность использования ptrace выглядит следующим образом:

\begin{enumerate}
	\item родительский процесс (tracer) создаёт свою копию при помощи \ic{fork};
	
	\item созданный дочерний процесс, возможно, выполняет некоторый код инициализации и сообщает, что хочет стать целью отслеживания через \ic{ptrace(PTRACE\_TRACEME)};
	
	\item созданный дочерний процесс выполняет запуск целевого исполняемого файла через ещё один системный вызов \ic{execve};
	
	\item родительский процесс ожидает сообщений от дочернего процесса через системные вызовы вроде \ic{waitpid}. На основании полученной информации родительский процесс понимает, в каком состоянии находится дочерний, взаимодействует с ним и отдаёт команды о продолжении выполнения.
\end{enumerate}

Применяя \ic{ptrace}, мы можем отслеживать процесс выполнения программы с нужным уровнем гранулярности путём расстановки точек останова в начале функций или базовых блоков. Алгоритм обработки точек останова выглядит следующим образом:

\begin{enumerate}
	\item программа-трассировщик выбирает участки кода, в которых выставляются точки останова. Это можно сделать, при помощи анализа исполняемого файла, добывая информацию из таблицы символов для обнаружения функций или анализируя непосредственно код программы, тем самым выявляя инструкции, изменяющие поток выполнения програмы;
	
	\item исследуемый исполняемый файл загружается в память через \ic{fork} и \ic{execve}, как было описано выше, и ставится на паузу;
	
	\item байт инструкции, расположенный по интересующему нас адресу заменяется на байт $\mathtt{0xCC}_{16}$, что соответствует ассемблерной инструкции \ic{INT 3}, вызывающей прерывание точки останова, а прежнее значение по этому адресу запоминается;
	
	\item когда все инструкции прерываний расставлены, дочерний процесс запускается, программа-трассировщик ожидает появления прерываний;
	
	\item при возникновении прерывания трассировщик может узнать, где оно возникло, из регистра счётчика команд. Выполнив необходимую логику, программа-трассировщик заменяет команду на ранее сохранённое значение;
	
	\item происходит запуск дочерней программы в режиме выполнения одной инструкции, за счёт чего происходит выполнение кода, изначально заложенного в программу, после чего управление снова передаётся трассировщику;
	
	\item трассировщик снова заменяет байт на \ic{INT 3}, тем самым возвращая точку останова в программу, после чего можно продолжить выполнение дочерней программы.
\end{enumerate}

\subsection{Преимущества и ограничения}

Трассировка при помощи точек останова является лишь одним из доступных подходов, и данный подход имеет как преимущества, так и недостатки. Из плюсов, выгодно выделяющих его на фоне других ранее перечисленных можно выделить:

\begin{itemize}
	\item отсутствие необходимости в модификации исследуемой программы, и за счёт этого более низкий порог входа. Благодаря отсутствию необходимости применения инструментов вроде специального компилятора или работы с исходным кодом мы получаем систему, которую достаточно запустить на уже имеющемся у пользователя исполняемом файле;
	
	\item приемлемая скорость выполнения. За счёт запуска программы средствами, предоставляемыми самой операционной системой, мы имеем скорость выполнения, по большому счёту совпадающую с таковой при запуске той же программы пользователем. Единственный источник замедления -- обработка системных вызовов и межпроцессного взаимодействия при работе с \ic{ptrace}.
\end{itemize}

В то же время можно выделить ряд недостатков и ограничений:

\begin{itemize}
	\item необходимость проведения, возможно довольно сложного, анализа исследуемого файла. В том случае, если мы хотим иметь покрытие на уровне базовых блоков, нам необходимо проводить анализ всего исполняемого машинного кода;
	
	\item вытекающая из предыдущего пункта более низкая универсальность. Анализ, который мы можем провести, не всегда будет способен полноценно извлечь заложенный в программу функционал, и не позволит работать с программами, скомпилированными при помощи инструментов обфускации, в которых может, например, применяться модификация исполняемого кода или переходы по адресам, не совпадающим с адресами выделенных во время анализа инструкций (поскольку довольно большая доля байтовых последовательностей могут интерпретироваться как команды в наборе команд x86 с учётом поддержки инструкций переменной длинны и того факта, что платформа x86 не накладывает требований на выравнивание инструкций);
	
	\item проблемы при работе со статически слинкованными исполняемыми файлами -- фаззер просто не будет знать, какая часть программы является важной и должна тестироваться и будет уделять большую долю времени анализу библиотечного кода вместо интересующей нас пользовательской части. Эта проблема частично разрешается предоставлением пользователю возможности указывать области исполняемых файлов, в которые будут добавляться точки останова, но это в свою очередь означает дополнительный анализ и конфигурацию со стороны пользователя.
\end{itemize}

Резюмируя, можно сказать, что выбранный способ трассировки предоставляет ряд преимуществ, но конечному пользователю стоит знать и о недостатках, ввиду которых в некоторых случаях, вероятно, стоит сделать выбор в пользу другого решения. Тем не менее стоит отметить, что фаззер покрывает основной пользовательский сценарий -- написанные на языках C или C++ программы, для которых не проводилась обфускация и выполнялась динамическая линковка.